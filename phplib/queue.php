<?php
/* 
 * THIS FILE WAS AUTOMATICALLY GENERATED BY ./rabxtophp.pl, DO NOT EDIT DIRECTLY
 * 
 * msg.php:
 * Client interface for management of message queue for FYR.
 *
 * Copyright (c) 2005 UK Citizens Online Democracy. All rights reserved.
 * WWW: http://www.mysociety.org
 *
 * $Id: queue.php,v 1.59 2006-09-01 11:43:40 francis Exp $
 *
 */

require_once('../../phplib/rabx.php');

/* msg_get_error R
 * Return FALSE if R indicates success, or an error string otherwise. */
function msg_get_error($e) {
    if (!rabx_is_error($e))
        return FALSE;
    else
        return $e->text;
}

/* msg_check_error R
 * If R indicates failure, displays error message and stops procesing. */
function msg_check_error($data) {
    if ($error_message = msg_get_error($data))
        err($error_message);
}

$msg_client = new RABX_Client(OPTION_FYR_QUEUE_URL, 
    defined('OPTION_FYR_QUEUE_USERPWD') ? OPTION_FYR_QUEUE_USERPWD : null);

define('FYR_QUEUE_MESSAGE_ALREADY_QUEUED', 4001);        /*    Tried to send message which has already been sent.  */
define('FYR_QUEUE_MESSAGE_ALREADY_CONFIRMED', 4002);        /*    Tried to confirm message which has already been confirmed.  */
define('FYR_QUEUE_MESSAGE_BAD_ADDRESS_DATA', 4003);        /*    Contact data not available for that representative.  */
define('FYR_QUEUE_MESSAGE_SHAME', 4004);        /*    Representative does not want to be contacted   */

/* msg_create

  Return an ID for a new message. Message IDs are 20 characters long and
  consist of characters [0-9a-f] only. */
function msg_create() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.create', $params);
    return $result;
}

/* msg_recipient_test RECIPIENT

  Verifies the contact method of the recipient. Throws an error if they do
  not have a fax or email address corresponding to the contact method set
  for them. RECIPIENT is the DaDem ID number of the recipient. */
function msg_recipient_test($recipient) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.recipient_test', $params);
    return $result;
}

/* msg_write ID SENDER RECIPIENT TEXT [COBRAND] [COCODE]

  Write details of a message for sending. ID is the identity of the
  message,

  SENDER is a reference to hash containing details of the sender including
  elements: name, the sender's full name; email, their email address;
  address, their full postal address; postcode, their post code; and
  optionally phone, their phone number; ipaddr, their IP address; referrer,
  website that referred them to this one. 

  RECIPIENT is the DaDem ID number of the recipient of the message; and
  TEXT is the text of the message, with line breaks. Returns true on
  success, or an error code on failure.

  COBRAND is the name of cobranding partner (e.g. "cheltenham"), and COCODE
  is a reference code for them.

  This function is called remotely and commits its changes. */
function msg_write($id, $sender, $recipient, $text, $cobrand = null, $cocode = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.write', $params);
    return $result;
}

/* msg_state ID [STATE]

  Get/change the msg_state of the message with the given ID to STATE. If STATE
  is the same as the current msg_state, just update the lastaction and
  numactions fields; if it isn't, then set the lastaction field to null,
  the numactions field to 0, and update the lastmsg_statechange field. If a
  message is moved to the "failed" or "finished" msg_states, then it is
  stripped of personal identifying information. */
function msg_state($id, $state = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.state', $params);
    return $result;
}

/* msg_actions ID

  Get the number of msg_actions taken on this message while in the current
  state. */
function msg_actions($id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.actions', $params);
    return $result;
}

/* msg_secret

  Wrapper for FYR::DB::msg_secret, for remote clients. */
function msg_secret() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.secret', $params);
    return $result;
}

/* msg_confirm_email TOKEN

  Confirm a user's email address, based on the TOKEN they've supplied in a
  URL which they've clicked on. This function is called remotely and
  commits its changes. Returns id of the message on success, or 0 for
  failure. Can be called multiple times for the same message with no harm,
  just returns the id again. */
function msg_confirm_email($token) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.confirm_email', $params);
    return $result;
}

/* msg_record_questionnaire_answer TOKEN QUESTION RESPONSE

  Record a user's response to a questionnaire question. TOKEN is the token
  sent them in the questionnaire email; QUESTION must be 0 or 1 and
  RESPONSE must be "YES", indicating that they have received a reply, or
  "NO", indicating that they have not. Returns 0 upon failure, or msgid
  upon success. */
function msg_record_questionnaire_answer($token, $question, $response) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.record_questionnaire_answer', $params);
    return $result;
}

/* msg_get_questionnaire_message TOKEN

  Return id of the message associated with a questionnaire email. TOKEN is
  the token sent them in the questionnaire email;. */
function msg_get_questionnaire_message($token) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.get_questionnaire_message', $params);
    return $result;
}

/* msg_get_time

  Returns the current time, in Unix seconds since epoch. This may not be
  the real world time, as it can be overriden in the database for the test
  script. */
function msg_get_time() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.get_time', $params);
    return $result;
}

/* msg_get_date

  Returns the current date, in iso format. This may not be the real world
  date, as it can be overriden in the database for the test script. */
function msg_get_date() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.get_date', $params);
    return $result;
}

/* msg_admin_recent_events COUNT [IMPORTANT]

  Returns an array of hashes of information about the most recent COUNT
  queue events. If IMPORTANT is true, only return information about
  "exceptional" messages. */
function msg_admin_recent_events($count, $important = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_recent_events', $params);
    return $result;
}

/* msg_admin_message_events ID [IMPORTANT]

  Returns an array of hashes of information about events for given message
  ID. If IMPORTANT is true, only request messages for which the
  "exceptional" flag is set. You probably don't need to display the
  'editor' field as it is also shown in the message content. */
function msg_admin_message_events($id, $important = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_message_events', $params);
    return $result;
}

/* msg_admin_get_queue WHICH PARAMS

  Returns an array of hashes of information about each message on the
  queue. WHICH and PARAMS indicates which messages should be returned;
  values of WHICH are as follows:

  * all

    All messages on the queue.

  * needattention

    Messages which need attention. This means frozen in states ready, or in
    bounce_confirm. (new and pending are excluded as often people sent test
    messages to themselves which break rules, but they never confirm).

  * failing

    Messages which are failing or have failed to be delivered, which have
    not been frozen. Combined with 'frozen' makes all 'important' messages.

  * recentchanged

    Up to 100 of the messages which have most recently changed state.

  * recentcreated

    Up to 100 of the messages which have recently been created.

  * similarbody

    Messages which are similar to the message with ID given in
    PARAMS->{msgid}.

  * search

    Messages which contain terms from PARAMS->{query}. Sender and recipient
    details are searched, as well as matching confirmation tokens.

  * logsearch

    Messages which contain the string in an item in their message log.
    Deliberately doesn't strip spaces or punctuation, and looks for whole
    strings, so you can search for ' rule #6 ' and the like.

  * type

    All messages which were sent to representative of type PARAMS->{type}. 

  * rep_id

    All messages which were sent to representative PARAMS->{rep_id}. */
function msg_admin_get_queue($which, $params) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_queue', $params);
    return $result;
}

/* msg_admin_get_message ID

  Returns a hash of information about message with id ID. */
function msg_admin_get_message($id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_message', $params);
    return $result;
}

/* msg_admin_get_stats [AMOUNT]

  Returns a hash of statistics about the queue. AMOUNT is not present, or 0
  to get just basic stats, 1 to get more details (slower). */
function msg_admin_get_stats($amount = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_stats', $params);
    return $result;
}

/* msg_admin_get_popular_referrers TIME

  Returns list of pairs of popular referrers and how many times they
  appeared in the last TIME seconds. */
function msg_admin_get_popular_referrers($time) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_popular_referrers', $params);
    return $result;
}

/* msg_admin_freeze_message ID USER

  Freezes the message with the given ID, so it won't be actually sent to
  the representative until thawed. USER is the administrator's name. */
function msg_admin_freeze_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_freeze_message', $params);
    return $result;
}

/* msg_admin_thaw_message ID USER

  Thaws the message with the given ID, so it will be sent to the
  representative. USER is the administrator's name. */
function msg_admin_thaw_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_thaw_message', $params);
    return $result;
}

/* msg_admin_no_questionnaire_message ID USER

  Mark the message as being one for which a questionnaire is not sent.
  Deletes any existing questionnaires. USER is the administrator's name. */
function msg_admin_no_questionnaire_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_no_questionnaire_message', $params);
    return $result;
}

/* msg_admin_yes_questionnaire_message ID USER

  Mark the message as being one for which a quesionnaire is sent. USER is
  the administrator's name. */
function msg_admin_yes_questionnaire_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_yes_questionnaire_message', $params);
    return $result;
}

/* msg_admin_set_message_to_error ID USER

  Moves message with given ID to error state, so aborting any further
  action, and sending a delivery failure notice to the constituent. USER is
  the administrator's name. */
function msg_admin_set_message_to_error($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_error', $params);
    return $result;
}

/* msg_admin_set_message_to_failed ID USER

  Moves message with given ID to failed state, aborting any further action.
  The constituent is not told. USER is the administrator's name. */
function msg_admin_set_message_to_failed($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_failed', $params);
    return $result;
}

/* msg_admin_set_message_to_failed_closed ID USER

  Moves message from failed to failed_closed state to indicate that it has
  been dealt with by an administrator. USER is the administrator's name. */
function msg_admin_set_message_to_failed_closed($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_failed_closed', $params);
    return $result;
}

/* msg_admin_set_message_to_bounce_wait ID USER

  Move message ID from bounce_confirm to bounce_wait. USER is the name of
  the administrator making the change. */
function msg_admin_set_message_to_bounce_wait($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_bounce_wait', $params);
    return $result;
}

/* msg_admin_add_note_to_message ID USER NOTE

  Add text in NOTE to the message log for the message ID; USER is the name
  of the administrator leaving the note. */
function msg_admin_add_note_to_message($id, $user, $note) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_add_note_to_message', $params);
    return $result;
}

/* msg_admin_set_message_to_ready ID USER

  Move message ID (from, probably, pending) to ready. USER is the name of
  the administrator making the change. */
function msg_admin_set_message_to_ready($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_ready', $params);
    return $result;
}

/* msg_admin_get_diligency_queue TIME

  Returns how many actions each administrator has done to the queue since
  unix time TIME. Data is returned as an array of pairs of count, name with
  largest counts first. */
function msg_admin_get_diligency_queue($time) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_diligency_queue', $params);
    return $result;
}


?>
