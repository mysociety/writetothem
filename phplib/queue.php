<?php
/* 
 * THIS FILE WAS ORIGINALLY AUTOMATICALLY GENERATED BY ./rabxtophp.pl,
 * but has been edited since.
 * 
 * queue.php:
 * Client interface for management of message queue for FYR.
 *
 */

require_once dirname(__FILE__) . "/../commonlib/phplib/rabx.php";

/* msg_get_error R
 * Return FALSE if R indicates success, or an error string otherwise. */
function msg_get_error($e) {
    if (!rabx_is_error($e))
        return FALSE;
    else
        return $e->text;
}

/* msg_check_error R
 * If R indicates failure, displays error message and stops procesing. */
function msg_check_error($data) {
    if ($error_message = msg_get_error($data))
        err($error_message);
}

if (defined('OPTION_FYR_QUEUE_URL')) {
    $msg_client = new RABX_Client(OPTION_FYR_QUEUE_URL, 
        defined('OPTION_FYR_QUEUE_USERPWD') ? OPTION_FYR_QUEUE_USERPWD : null);
    if (OPTION_HTTPS_ONLY && OPTION_WEB_DOMAIN == 'writetothem.test.mysociety.org') { # If in test
        curl_setopt($msg_client->ch, CURLOPT_SSL_VERIFYPEER, FALSE);
    }
}

define('FYR_QUEUE_MESSAGE_ALREADY_QUEUED', 4001);        /*    Tried to send message which has already been sent.  */
define('FYR_QUEUE_MESSAGE_ALREADY_CONFIRMED', 4002);        /*    Tried to confirm message which has already been confirmed.  */
define('FYR_QUEUE_MESSAGE_BAD_ADDRESS_DATA', 4003);        /*    Contact data not available for that representative.  */
define('FYR_QUEUE_MESSAGE_SHAME', 4004);        /*    Representative does not want to be contacted   */
define('FYR_QUEUE_GROUP_ALREADY_QUEUED', 4006);        /*    Tried to send group of messages which has already been sent.  */
define('FYR_QUEUE_MESSAGE_EXPIRED', 4009);        /*    Tried to confirm a message that has expired (and possibly been scrubbed) */

/* msg_create

  Return an ID for a new message. Message IDs are 20 characters long and
  consist of characters [0-9a-f] only. */
function msg_create() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.create', $params);
    return $result;
}

/* msg_create_group

  Return an ID for a new group of messages. Group IDs, like messages IDs,
  are 20 characters long and consist of characters [0-9a-f] only. */
function msg_create_group() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.create_group', $params);
    return $result;
}

/* msg_check_group_unused GROUP_ID

  Throws an error if the GROUP_ID is already present in the message table */
function msg_check_group_unused($group_id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.check_group_unused', $params);
    return $result;
}

/* msg_recipient_test RECIPIENT

  Verifies the contact method of the recipient. Throws an error if they do
  not have a fax or email address corresponding to the contact method set
  for them. RECIPIENT is the DaDem ID number of the recipient. */
function msg_recipient_test($recipient) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.recipient_test', $params);
    return $result;
}

/* msg_write_messages IDLIST SENDER RECIPIENTLIST TEXT [COBRAND] [COCODE]
  [GROUP_ID] [NO_QUESTIONNAIRE]

  Write details of a set of messages for sending in one transaction.

  IDLIST is a list of the identities of the messages,

  SENDER is a reference to hash containing details of the sender including
  elements: name, the sender's full name; email, their email address;
  address, their full postal address; postcode, their post code; and
  optionally phone, their phone number; ipaddr, their IP address; referrer,
  website that referred them to this one. 

  RECIPIENTLIST is a list of is the DaDem ID numbers of the recipients of
  the message; and TEXT is the text of the message, with line breaks. 

  COBRAND is the name of cobranding partner (e.g. "cheltenham"), and COCODE
  is a reference code for them.

  GROUP_ID is the identity of a group of messages sent by the same sender
  at the same time with the same content to a group of representatives.

  NO_QUESTIONNAIRE is an optional flag indicating that no questionnaires
  should be sent for these messages

  Returns an associative array keyed on message ID. Each value is a
  associative array with the following keys

  'recipient_id' - DaDem id of the recipient 'status_code' - 0 = success, 1
  = FYR::Error in queueing, 2 = Flagged for abuse 'abuse_result' - result
  of abuse flagging or undef 'error_code' - FYR::Error code or undef
  'error_text'- FYR::Error text or undef

  This function is called remotely and commits its changes. */
function msg_write_messages($idlist, $sender, $recipientlist, $text, $cobrand = null, $cocode = null, $group_id = null, $no_questionnaire = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.write_messages', $params, 1);
    return $result;
}

/* msg_state ID [STATE]

  Get/change the msg_state of the message with the given ID to STATE. If STATE
  is the same as the current msg_state, just update the lastaction and
  numactions fields; if it isn't, then set the lastaction field to null,
  the numactions field to 0, and update the lastmsg_statechange field. If a
  message is moved to the "failed" or "finished" msg_states, then it is
  stripped of personal identifying information. */
function msg_state($id, $state = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.state', $params);
    return $result;
}

/* msg_group_state ID [STATE] [GROUP_ID]

  If the message with the ID passed belongs to a group, get/change the
  state of the messages in the group with the given ID to STATE, using the
  state method. Otherwise get/change the state of the message, using the
  state method. */
function msg_group_state($id, $state = null, $group_id = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.group_state', $params);
    return $result;
}

/* msg_group_messages GROUP_ID

  Return an array of the IDs for messages in the group GROUP_ID */
function msg_group_messages($group_id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.group_messages', $params);
    return $result;
}

/* msg_other_recipient_list GROUP_ID ID

  Return a string consisting of comma-delimited recipient names for other
  messages in GROUP_ID, omitting the recipient of message ID */
function msg_other_recipient_list($group_id, $id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.other_recipient_list', $params);
    return $result;
}

/* msg_actions ID

  Get the number of msg_actions taken on this message while in the current
  state. */
function msg_actions($id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.actions', $params);
    return $result;
}

/* msg_secret

  Wrapper for FYR::DB::msg_secret, for remote clients. */
function msg_secret() {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.secret', $params);
    return $result;
}

/* msg_confirm_email TOKEN

  Confirm a user's email address, based on the TOKEN they've supplied in a
  URL which they've clicked on. This function is called remotely and
  commits its changes. Returns id of the message on success, or 0 for
  failure. Can be called multiple times for the same message with no harm,
  just returns the id again. */
function msg_confirm_email($token) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.confirm_email', $params);
    return $result;
}

/* msg_record_questionnaire_answer TOKEN QUESTION RESPONSE

  Record a user's response to a questionnaire question. TOKEN is the token
  sent them in the questionnaire email; QUESTION must be 0 or 1 and
  RESPONSE must be "YES", indicating that they have received a reply, or
  "NO", indicating that they have not. Returns 0 upon failure, or msgid
  upon success. */
function msg_record_questionnaire_answer($token, $question, $response) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.record_questionnaire_answer', $params);
    return $result;
}

/* msg_get_questionnaire_message TOKEN

  Return id of the message associated with a questionnaire email. TOKEN is
  the token sent them in the questionnaire email;. */
function msg_get_questionnaire_message($token) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.get_questionnaire_message', $params);
    return $result;
}

/* msg_admin_recent_events COUNT [IMPORTANT]

  Returns an array of hashes of information about the most recent COUNT
  queue events. If IMPORTANT is true, only return information about
  "exceptional" messages. */
function msg_admin_recent_events($count, $important = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_recent_events', $params);
    return $result;
}

/* msg_admin_message_events ID [IMPORTANT]

  Returns an array of hashes of information about events for given message
  ID. If IMPORTANT is true, only request messages for which the
  "exceptional" flag is set. You probably don't need to display the
  'editor' field as it is also shown in the message content. */
function msg_admin_message_events($id, $important = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_message_events', $params);
    return $result;
}

/* msg_admin_get_queue WHICH PARAMS

  Returns an array of hashes of information about each message on the
  queue. WHICH and PARAMS indicates which messages should be returned;
  values of WHICH are as follows:

  * all

    All messages on the queue.

  * needattention

    Messages which need attention. This means frozen in states ready, or in
    bounce_confirm. (new and pending are excluded as often people sent test
    messages to themselves which break rules, but they never confirm).

  * failing

    Messages which are failing or have failed to be delivered, which have
    not been frozen. Combined with 'frozen' makes all 'important' messages.

  * recentchanged

    Up to 100 of the messages which have most recently changed state.

  * recentcreated

    Up to 100 of the messages which have recently been created.

  * similarbody

    Messages which are similar to the message with ID given in
    PARAMS->{msgid}.

  * similarbodysamerep

    Messages which are similar to the message with ID given in
    PARAMS->{msgid}, and were sent to the same representative.

  * search

    Messages which contain terms from PARAMS->{query}. First confirmation
    and questionnaire tokens are looked for, then an exact match on sender
    email is done. Failing that, sender and recipient details are substring
    searched.

  * logsearch

    Messages which contain the string in an item in their message log.
    Deliberately doesn't strip spaces or punctuation, and looks for whole
    strings, so you can search for ' rule #6 ' and the like.

  * type

    All messages which were sent to representative of type PARAMS->{type}. 

  * rep_id

    All messages which were sent to representative PARAMS->{rep_id}. */
function msg_admin_get_queue($which, $params) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_queue', $params);
    return $result;
}

/* msg_admin_get_message ID

  Returns a hash of information about message with id ID. */
function msg_admin_get_message($id) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_message', $params);
    return $result;
}

/* msg_admin_get_stats [AMOUNT]

  Returns a hash of statistics about the queue. AMOUNT is not present, or 0
  to get just basic stats, 1 to get more details (slower). */
function msg_admin_get_stats($amount = null) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_stats', $params);
    return $result;
}

/* msg_admin_get_popular_referrers TIME

  Returns list of pairs of popular referrers and how many times they
  appeared in the last TIME seconds. */
function msg_admin_get_popular_referrers($time) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_popular_referrers', $params);
    return $result;
}

/* msg_admin_freeze_message ID USER

  Freezes the message with the given ID, so it won't be actually sent to
  the representative until thawed. USER is the administrator's name. */
function msg_admin_freeze_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_freeze_message', $params);
    return $result;
}

/* msg_admin_thaw_message ID USER

  Thaws the message with the given ID, so it will be sent to the
  representative. USER is the administrator's name. */
function msg_admin_thaw_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_thaw_message', $params);
    return $result;
}

/* msg_admin_no_questionnaire_message ID USER

  Mark the message as being one for which a questionnaire is not sent.
  Deletes any existing questionnaires. USER is the administrator's name. */
function msg_admin_no_questionnaire_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_no_questionnaire_message', $params);
    return $result;
}

/* msg_admin_yes_questionnaire_message ID USER

  Mark the message as being one for which a quesionnaire is sent. USER is
  the administrator's name. */
function msg_admin_yes_questionnaire_message($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_yes_questionnaire_message', $params);
    return $result;
}

/* msg_admin_set_message_to_error ID USER

  Moves message with given ID to error state, so aborting any further
  action, and sending a delivery failure notice to the constituent. USER is
  the administrator's name. */
function msg_admin_set_message_to_error($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_error', $params);
    return $result;
}

/* msg_admin_set_message_to_failed ID USER

  Moves message with given ID to failed state, aborting any further action.
  The constituent is not told. USER is the administrator's name. */
function msg_admin_set_message_to_failed($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_failed', $params);
    return $result;
}

/* msg_admin_set_message_to_failed_closed ID USER

  Moves message from failed to failed_closed state to indicate that it has
  been dealt with by an administrator. USER is the administrator's name. */
function msg_admin_set_message_to_failed_closed($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_failed_closed', $params);
    return $result;
}

/* msg_admin_set_message_to_bounce_wait ID USER

  Move message ID from bounce_confirm to bounce_wait. USER is the name of
  the administrator making the change. */
function msg_admin_set_message_to_bounce_wait($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_bounce_wait', $params);
    return $result;
}

/* msg_admin_add_note_to_message ID USER NOTE

  Add text in NOTE to the message log for the message ID; USER is the name
  of the administrator leaving the note. */
function msg_admin_add_note_to_message($id, $user, $note) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_add_note_to_message', $params);
    return $result;
}

/* msg_admin_get_wire_email ID TYPE

  Returns the text of an email as would be sent for this message in various
  circumstances. The TYPE can be representative, confirm, confirm-reminder,
  failure, questionnaire or questionnaire-reminder. */
function msg_admin_get_wire_email($id, $type) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_wire_email', $params);
    return $result;
}

/* msg_admin_set_message_to_ready ID USER

  Move message ID (from, probably, pending) to ready. USER is the name of
  the administrator making the change. */
function msg_admin_set_message_to_ready($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_set_message_to_ready', $params);
    return $result;
}

/* msg_admin_get_diligency_queue TIME

  Returns how many actions each administrator has done to the queue since
  unix time TIME. Data is returned as an array of pairs of count, name with
  largest counts first. */
function msg_admin_get_diligency_queue($time) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_get_diligency_queue', $params);
    return $result;
}

function msg_admin_scrub_data($id, $user) {
    global $msg_client;
    $params = func_get_args();
    $result = $msg_client->call('FYR.Queue.admin_scrub_data', $params);
    return $result;
}
