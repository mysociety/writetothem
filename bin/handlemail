#!/usr/bin/perl -w
#
# handlemail:
# Handle an individual incoming mail message.
#
# This script should be invoked through the .forward mechanism. It processes
# bounce messages and saves their text in the database for review by an
# administrator.
#
# Copyright (c) 2004 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: handlemail,v 1.22 2006-04-06 13:57:41 matthew Exp $';

use strict;
require 5.8.0;

# Horrible boilerplate to set up appropriate library paths.
use FindBin;
use lib "$FindBin::Bin/../perllib";
use lib "$FindBin::Bin/../../perllib";

use IO::Handle;
use Mail::Address;
use Mail::Internet;
use Mail::Header;
use MIME::Entity;
use MIME::Words;
use POSIX qw(strftime);

use mySociety::Config;
BEGIN {
    mySociety::Config::set_file("$FindBin::Bin/../conf/general");
}
use mySociety::DBHandle qw(dbh);
use mySociety::Util qw(print_log);

# Don't print diagnostics to standard error, as this can result in bounce
# messages being generated (only in response to non-bounce input, obviously).
mySociety::Util::log_to_stderr(0);

use FYR;
use FYR::EmailTemplate;
use FYR::Queue;

my @lines = ( );

my $is_bounce_message = 0;

while (defined($_ = STDIN->getline())) {
    chomp();
    # Skip any From_ line-- we don't need it. BUT, on some systems (e.g.
    # FreeBSD with default exim config), there will be no Return-Path in a
    # message even at final delivery time. So use the insanely ugly
    # "From MAILER-DAEMON ..." thing to distinguish bounces, if it is present.
    if (@lines == 0 and m#^From #) {
        $is_bounce_message = 1 if (m#^From MAILER-DAEMON #);
    } else {
        push(@lines, $_);
    }
}

if (STDIN->error()) {
    # Failed to read it; should defer.
    print_log('err', "read message from standard input: $!; deferring");
    exit(75);   # EX_TEMPFAIL
}

my $m = new Mail::Internet([@lines]);
if (!defined($m)) {
    # Unable to parse message; should drop.
    print_log('err', "unable to parse message from standard input; discarding");
    exit(1);
}

if (!$is_bounce_message) {
    # RFC2822: 'The "Return-Path:" header field contains a pair of angle
    # brackets that enclose an optional addr-spec.'
    my $return_path = $m->head()->get("Return-Path");

    if (!defined($return_path)) {
        # No Return-Path; we're screwed.
        print_log('err', "message had no Return-Path and was not a bounce according to any From_ line; discarding");
        print_log('err', "configure your MDA to add a Return-Path to messages at delivery time");
        exit(0);
    } elsif ($return_path =~ m#<>#) {
        $is_bounce_message = 1;
    } else {
        # This is not a bounce message. We pass it on to team@writetothem.com,
        # and also send a patronising response about clicking the link.
        print_log('info', "message was not a bounce message");
        
        # First, send this to team@writetothem.com.
        if (mySociety::Util::EMAIL_SUCCESS
                != mySociety::Util::send_email(join("\n", @lines) . "\n", $return_path, 'team@writetothem.com')) {
            print_log('err', 'unable to forward non-bounce to team@writetothem.com; deferring');
            exit(75);
        }

        # Now see whether the email contains one of our URLs.
        my $url;
        foreach (@lines) {
            if (m#(http://www\.writetothem\.com/[CNY]/[2-7A-Za-z]{10}[./]?[2-7A-Za-z]{10,})#) {
                $url = $1;
                last;
            }
        }

        if ($url) {
            print_log('info', "mail contains confirmation URL $url");
            my $h = dbh();
            local $h->{HandleError};
            if (!$h->do('
                        insert into confirmation_mail_autoreply
                                (url, whenreceived)
                        values (?, ?)',
                        {}, $url, time())) {
                # Have already sent an autoreply to this one.
                print_log('info', "have already sent one autoresponse for this confirm URL");
                exit(0);
            }
        } else {
            exit(0);
        }
        
        print_log('info', "sending patronising reply");

        # Now we need to construct some text to send to them.
        my $vv;
        if ($url =~ m#/C/#) {
            $vv = {
                    action => 'confirm your message so that we can send it',
                    which => 'the link'
                };
        } else {
            $vv = {
                    action => 'complete our questionnaire',
                    which => 'one of the links'
                };
        }

        my $text = FYR::EmailTemplate::format(
                        FYR::Queue::email_template('reply-autoresponse'),
                        $vv
                    )
                    . "\n\n$url\n";

        $text = FYR::Queue::wrap(FYR::Queue::EMAIL_COLUMNS, $text);

        my $from = sprintf('%sbounce-null@%s',
                        mySociety::Config::get('EMAIL_PREFIX'),
                        mySociety::Config::get('EMAIL_DOMAIN'));

        # We generate this as a bounce.
        my $mail = MIME::Entity->build(
                        Sender => '<>',
                        From => FYR::Queue::format_email_address("WriteToThem", $from),
                        To => $return_path,
                        Subject => 'Automatic reply to your message to WriteToThem',
                        Date => strftime('%a, %e %b %Y %H:%M:%S %z', localtime(FYR::DB::Time())),
                        Type => 'text/plain; charset="utf-8"',
                        Encoding => 'quoted-printable',
                        Data => FYR::Queue::as_utf8_octets($text)
                    );
        
        if (mySociety::Util::EMAIL_SUCCESS
                != mySociety::Util::send_email($mail->stringify(), '<>', $return_path)) {
            print_log('err', 'unable to send patronising reply; deferring');
            exit(75);
        }

        dbh()->commit();
        
        exit(0);
    }
}

# Now we have a bounce. We need to know the address to which it was sent so
# that we can distinguish VERP bounces (which must be recorded) from others
# which we don't care about.
my $to = $m->head()->get("To");

if (!defined($to)) {
    # Not a lot we can do without an address to parse.
    print_log('err', "received bounce message had no To: header; discarding");
    exit(0);
}

my ($a) = Mail::Address->parse($to);

if (!defined($a)) {
    # Couldn't parse first To: address.
    print_log('err', "unable to parse address from To: header '$to' in received bounce message; discarding");
    exit(0);
}

my $prefix = mySociety::Config::get("EMAIL_PREFIX");
if ($a->user() !~ m#^\Q$prefix\E# or lc($a->host()) ne lc(mySociety::Config::get("EMAIL_DOMAIN"))) {
    # Not one of our bounces; discard.
    print_log('info', "bounce sent to '" . $a->address() . "' is not for us; discarding");
    exit(0);
}

# NB we make no assumptions about the contens of the token.
my ($token) = ($a->user() =~ m#^\Q$prefix\E(.*)#);
#print "token $token\n";

my $id;
if ($token eq 'bounce-null') {
    print_log('warning', "bounce received for don't-care email");
} elsif (defined($id = FYR::Queue::check_token('bounce', $token))) {
    my $msg = FYR::Queue::message($id, 1);    # lock message
    if (!defined($msg)) {
        print_log('err', "bounce received for non-existant message '$id'; discarding");
        dbh()->rollback();
    } else {
        # Record the bounce
        FYR::Queue::logmsg($id, 1, "received email bounce message");
        if ($msg->{state} eq 'bounce_wait') {
            FYR::Queue::state($id, 'bounce_confirm');
        }
        dbh()->do('insert into message_bounce (message_id, whenreceived, bouncetext) values (?, ?, ?)', {}, $id, time(), join("\n", @lines) . "\n");
        dbh()->commit();
    }
} else {
    print_log('err', "received bounce with invalid token '$token'; discarding");
}

exit(0);
